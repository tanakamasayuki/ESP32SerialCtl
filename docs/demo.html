<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Web Serial Minimal Sample</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      margin: 24px;
      display: grid;
      gap: 16px;
    }

    button {
      padding: 8px 16px;
      font-size: 14px;
    }

    textarea {
      width: 100%;
      min-height: 160px;
      font-family: 'JetBrains Mono', 'Fira Code', ui-monospace, SFMono-Regular, monospace;
    }

    .row {
      display: flex;
      gap: 8px;
    }

    .status {
      font-weight: 600;
    }
  </style>
</head>

<body>
  <div class="row">
    <button id="connect">Connect</button>
    <button id="disconnect" disabled>Disconnect</button>
    <span class="status" id="status">Disconnected</span>
  </div>

  <div class="row">
    <input id="outgoing" type="text" placeholder="Text to send" style="flex:1" />
    <button id="send" disabled>Send</button>
  </div>

  <label for="incoming">Incoming Data</label>
  <textarea id="incoming" readonly></textarea>

  <script>
    const connectButton = document.getElementById('connect');
    const disconnectButton = document.getElementById('disconnect');
    const sendButton = document.getElementById('send');
    const outgoingInput = document.getElementById('outgoing');
    const incomingArea = document.getElementById('incoming');
    const statusText = document.getElementById('status');

    let port = null;
    let reader = null;
    let writer = null;
    let readLoopAbortController = null;
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();

    const setStatus = (text) => {
      statusText.textContent = text;
    };

    const appendIncoming = (text) => {
      incomingArea.value += text + '\n';
      incomingArea.scrollTop = incomingArea.scrollHeight;
    };

    const startReadLoop = async () => {
      if (!port?.readable) {
        return;
      }
      readLoopAbortController = new AbortController();
      const signal = readLoopAbortController.signal;
      reader = port.readable.getReader();
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) {
            break;
          }
          if (value) {
            appendIncoming(decoder.decode(value));
          }
          if (signal.aborted) {
            break;
          }
        }
      } catch (error) {
        appendIncoming(`[ERROR] ${error.message}`);
      } finally {
        if (reader) {
          reader.releaseLock();
          reader = null;
        }
      }
    };

    const stopReadLoop = async () => {
      if (readLoopAbortController) {
        readLoopAbortController.abort();
        readLoopAbortController = null;
      }
      const currentReader = reader;
      reader = null;
      if (currentReader) {
        currentReader
          .cancel()
          .catch((error) => console.warn('Reader cancel error:', error));
        try {
          currentReader.releaseLock();
        } catch (error) {
          console.warn('Reader release error:', error);
        }
      }
    };

    const closePort = async () => {
      await stopReadLoop();
      if (writer) {
        try {
          await writer.close();
        } catch (error) {
          /* ignore */
        }
        writer.releaseLock();
        writer = null;
      }
      if (port) {
        if (typeof port.setSignals === 'function') {
          try {
            await port.setSignals({ dataTerminalReady: false, requestToSend: false });
          } catch (error) {
            console.warn('setSignals error:', error);
          }
        }
        port
          .close()
          .then(() => console.info('Serial port closed.'))
          .catch((error) => console.warn('Port close error:', error));
        port = null;
      }
    };

    connectButton.addEventListener('click', async () => {
      if (!('serial' in navigator)) {
        alert('This browser does not support the Web Serial API.');
        return;
      }
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        if (port.writable) {
          writer = port.writable.getWriter();
        }
        setStatus('Connected');
        connectButton.disabled = true;
        disconnectButton.disabled = false;
        sendButton.disabled = false;
        startReadLoop();
      } catch (error) {
        setStatus(`Connection failed: ${error.message}`);
        port = null;
      }
    });

    disconnectButton.addEventListener('click', async () => {
      connectButton.disabled = false;
      disconnectButton.disabled = true;
      sendButton.disabled = true;
      setStatus('Disconnecting...');
      await closePort();
      setStatus('Disconnected');
    });

    sendButton.addEventListener('click', async () => {
      if (!writer) {
        alert('Not connected.');
        return;
      }
      const text = outgoingInput.value;
      if (!text) {
        return;
      }
      try {
        await writer.write(encoder.encode(text + '\n'));
      } catch (error) {
        appendIncoming(`[SEND ERROR] ${error.message}`);
      }
    });

    window.addEventListener('beforeunload', async () => {
      await closePort();
    });
  </script>
</body>

</html>